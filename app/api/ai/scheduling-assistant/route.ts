import { NextResponse } from "next/server";
import { bookingStore } from "../../../../lib/booking/store";
import { formatInTimezone, safeTimezone } from "../../../../lib/booking/time";

interface AssistantRequestBody {
  message?: string;
  timezone?: string;
  durationMinutes?: number;
}

function heuristicSuggestions(timezone: string, durationMinutes: number): string[] {
  const base = new Date();
  const slots = bookingStore.listActiveReservations();
  const suggestions: string[] = [];

  for (let offset = 1; offset <= 14 && suggestions.length < 3; offset += 1) {
    const start = new Date(base.getTime() + offset * 60 * 60 * 1000);
    const hour = Number(
      new Intl.DateTimeFormat("en-US", {
        timeZone: timezone,
        hour: "2-digit",
        hourCycle: "h23",
      }).format(start),
    );

    if (hour < 9 || hour >= 17) continue;

    const startUtc = start.toISOString();
    const endUtc = new Date(start.getTime() + durationMinutes * 60_000).toISOString();

    const hasConflict = slots.some((r) => {
      const aStart = new Date(r.startUtc).getTime();
      const aEnd = new Date(r.endUtc).getTime();
      const bStart = new Date(startUtc).getTime();
      const bEnd = new Date(endUtc).getTime();
      return aStart < bEnd && bStart < aEnd;
    });

    if (!hasConflict) {
      suggestions.push(formatInTimezone(startUtc, timezone));
    }
  }

  return suggestions;
}

async function requestOpenAiSuggestions(params: {
  message: string;
  timezone: string;
  durationMinutes: number;
  heuristic: string[];
}): Promise<string[] | null> {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) return null;

  const prompt = [
    "You are a scheduling assistant.",
    `Timezone: ${params.timezone}`,
    `Duration: ${params.durationMinutes} minutes`,
    `User request: ${params.message}`,
    `Available candidate times: ${params.heuristic.join(" | ") || "none"}`,
    "Return 3 concise options as plain text lines.",
  ].join("\n");

  const response = await fetch("https://api.openai.com/v1/responses", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: process.env.OPENAI_SCHEDULING_MODEL ?? "gpt-4.1-mini",
      input: prompt,
      temperature: 0.2,
    }),
  });

  if (!response.ok) return null;

  const json = (await response.json()) as {
    output_text?: string;
  };

  if (!json.output_text) return null;

  const lines = json.output_text
    .split("\n")
    .map((line) => line.replace(/^[-\d.\s]+/, "").trim())
    .filter(Boolean)
    .slice(0, 3);

  return lines.length > 0 ? lines : null;
}

export async function POST(request: Request) {
  let body: AssistantRequestBody;

  try {
    body = (await request.json()) as AssistantRequestBody;
  } catch {
    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400 });
  }

  if (!body.message) {
    return NextResponse.json({ error: "message is required." }, { status: 400 });
  }

  const timezone = safeTimezone(body.timezone);
  const durationMinutes = Number(body.durationMinutes ?? 30);
  const heuristic = heuristicSuggestions(timezone, durationMinutes);

  try {
    const aiOptions = await requestOpenAiSuggestions({
      message: body.message,
      timezone,
      durationMinutes,
      heuristic,
    });

    return NextResponse.json({
      timezone,
      suggestions: aiOptions ?? heuristic,
      source: aiOptions ? "openai" : "heuristic",
      note: aiOptions
        ? "Suggested times generated by OpenAI from current availability."
        : "OPENAI_API_KEY not configured or AI request failed. Returned deterministic fallback suggestions.",
    });
  } catch {
    return NextResponse.json({
      timezone,
      suggestions: heuristic,
      source: "heuristic",
      note: "AI service unavailable. Returned deterministic fallback suggestions.",
    });
  }
}
